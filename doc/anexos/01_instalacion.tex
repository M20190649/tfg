\documentclass[../proyecto.tex]{subfiles}

\begin{document}
\chapter{Instalación}\label{chap:anexo_instalacion}

\section{Sensor}\label{sect:instalacion_sensor}
Para compilar el proyecto y subir el binario a la placa es necesario instalar la herramienta \href{https://docs.platformio.org/en/latest/core/}{PlatformIO Core}, esta herramienta se encargará de descargar automáticamente la \textit{toolchain} y librerías necesarias para compilar el proyecto, además de otras herramientas para grabar el binario en la placa o monitorizar la salida del puerto \textit{Serial}.\\

En sistemas Linux podemos realizar la instalación con un simple comando sin necesidad de privilegios de administrador, este comando descargará y ejecutará un script de Python que realizará la instalación:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Comando para la instalación de PlatformIO Core, captionpos=b, frame=single]
$ python3 -c "$(curl -fsSL https://raw.githubusercontent.com/platformio/platformio/develop/scripts/get-platformio.py)"
\end{lstlisting}
\end{minipage}

Para otros sistemas operativos o métodos de instalación se puede consultar la \href{https://docs.platformio.org/en/latest/core/installation.html\#local-download-mac-linux-windows}{documentación oficial de PlatformIO}.\\

Esta instalación nos creará un entorno aislado en la ruta \textit{\$HOME/.platformio/penv/} con los binarios necesarios, podemos invocarlos especificando la ruta completa (\textit{\$HOME/.platformio/penv/bin/platformio}) o añadir los binarios al \textit{path} siguiendo las \href{https://docs.platformio.org/en/latest/core/installation.html\#unix-and-unix-like}{instrucciones de la documentación}. \\

Este proyecto ha sido desarrollado con las placas de desarrollo de la familia ESP32 DevKitC pero es compatible con cualquier otra placa basada en los SoCs ESP32, en caso de utilizar una placa diferente es necesario modificar el parámetro \textit{board} del fichero \textit{platformio.ini} con el identificador de la placa correspondiente, podemos encontrar el código de la placa buscando en el \href{https://platformio.org/boards}{explorador de PlatformIO}.\\

Antes de compilar el proyecto es necesario establecer el valor de algunas variables en el fichero \textit{src/main.cpp}.\\

\begin{itemize}
  \item DEBUG: Al establece su valor a 1 se imprimirá por el puerto \textit{Serial} información de depuración, por ejemplo, las detecciones realizadas o el JSON enviado al servidor central. Por defecto su valor es 0.
  \item WIFI\_SSID: SSID de la red WiFi a la que el sensor se conectará para enviar las detecciones.
  \item WIFI\_PASSWD: Contraseña de la red WiFi especificada.
  \item SERVER\_URL: URL del endpoint al que se enviaran las detecciones
  \linebreak (http://<host>:<puerto>/api/v1.0/detections-collection/)
\end{itemize}

Una vez instalado, especificada la placa de desarrollo a usar y configuradas las variables podemos lanzar la compilación y la subida del \textit{firmware} a la placa, para ello debemos situarnos en la raíz del proyecto dónde se encuentra el fichero \textit{platformio.ini} y ejecutar el siguiente comando:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Comando compilar y subir el \textit{firmware} a la placa de desarrollo, captionpos=b, frame=single]
$ platformio run --target upload
\end{lstlisting}
\end{minipage}

Cuando la subida finalice la placa se reiniciará y arrancará el nuevo \textit{firmware}, para monitorizar la salida del serial podemos ejecutar el siguiente comando:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Comando para monitorizar la salida \textit{Serial} de la placa de desarrollo, captionpos=b, frame=single]
$ platformio device monitor
\end{lstlisting}
\end{minipage}

Usando este comando en el arranque de la placa podremos obtener el identificador único (\textit{Station\_id}) de la placa que será necesario durante la instalación del servidor. En el siguiente código se puede ver un ejemplo de la información que muestra la placa por el puerto \textit{Serial} al arrancar.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Ejemplo de arranque de la placa de desarrollo, captionpos=b, frame=single]
Initializing system.
Generating station ID.
Station_id: 363daf8619557863c7b4f9767389cb6c
\end{lstlisting}
\end{minipage}


\section{Servidor Central}

Para el despliegue del servidor central podemos optar por dos opciones, un despliegue local utilizando la herramienta Docker Compose o un despliegue en remoto utilizando el proveedor PaaS Heroku, se recomienda especialmente este último método si el sensor y el servidor central se encuentran en diferentes redes ya que Heroku nos facilita exponer el servidor central a internet.

\subsection{Docker Compose}
Antes de realizar este tipo de despliegue es necesario instalar las aplicaciones  \href{https://docs.docker.com/get-docker/}{Docker} y \href{https://docs.docker.com/compose/install/}{Docker Compose}, ambas herramientas están disponibles para sistemas Linux, Mac y Windows.\\

También es necesario establecer algunas variables de entorno antes de realizar el despliegue, estas variables se establecerán en los ficheros indicados en las opciones \textit{env\_file} del fichero \textit{docker-compose.yml}, por defecto  \textit{web.env.sample} y \textit{db.env.sample}.\\

\noindent{\textbf{web.env}}
\begin{itemize}
  \item POSTGRES\_USER: Usuario principal que será creado en la base de datos y con el que contenedor del servicio web conectará.
  \item POSTGRES\_PASSWORD: Contraseña para el usuario especificado.
\end{itemize}

\noindent{\textbf{db.env}}
\begin{itemize}
  \item FLASK\_APP: Módulo Python que arrancará la aplicación Flask. El valor debe ser \textit{vedetra-server.py}.
  \item FLASK\_ENV: Define el tipo de servidor en el que se ejecutará \textit{development}, \textit{testing} o \textit{production}. Por defecto \textit{production}.
  \item FLASK\_CONFIG: Define la configuración de entorno que se cargará, puede tomar los valores  \textit{development}, \textit{testing} o \textit{production}. Por defecto \textit{production}.
  \item DATABASE\_URL: Dirección de la base de datos de producción \linebreak (postgresql://<user>:<password>@db/vedetra).
  \item LOAD\_DUMMY\_DATA: Cuando se establece a \textit{true} realiza una carga de sensores y detecciones falsas en la base de datos para ver una demostración de la interfaz. Por defecto \textit{false}
  \item PORT: Puerto en el que se expondrá la aplicación web. Por defecto el puerto 5000.
\end{itemize}

Una vez satisfechos los prerrequisitos podemos proceder al despliegue, para ello desde el directorio principal del proyecto, donde se encuentra el fichero \textit{docker-compose.yml},  podemos lanzar el siguiente comando que se encargará de construir la imagen y desplegar los contenedores.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Despliegue con \textit{docker-compose.yml}, captionpos=b, frame=single]
$ docker-compose up --build
\end{lstlisting}
\end{minipage}

\subsection{Heroku}
Para este despliegue es necesario disponer de una cuenta en \href{https://www.heroku.com/}{Heroku}, para desplegar estos recursos podemos utilizar la cuenta gratuita que nos ofrecen. También será necesario instalar la herramienta Heroku CLI, en sistemas Linux podemos instalarla con un simple comando:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Instalación de Heroku CLI, captionpos=b, frame=single]
$ curl https://cli-assets.heroku.com/install.sh | sh
\end{lstlisting}
\end{minipage}

Para otros métodos de instalación o sistemas operativos consultar la \href{https://devcenter.heroku.com/articles/heroku-cli\#download-and-install}{documentación oficial}.\\

Una vez creada la cuenta e instalada la herramienta Heroku CLI el primer paso será iniciar sesión usando el siguiente comando:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Instalación de Heroku CLI, captionpos=b, frame=single]
$ heroku login -i
\end{lstlisting}
\end{minipage}

El método de despliegue de Heroku se basa en subidas al repositorio Git de Heroku, por lo que si la copia que tenemos del proyecto no ha sido clonada del repositorio de GitHub el primer paso será inicializar un repositorio, para ello nos situamos en la raíz del proyecto y ejecutamos el siguiente comando:\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Inicialización del repositorio para la aplicación de Heroku, captionpos=b, frame=single]
$ git init
\end{lstlisting}
\end{minipage}

El siguiente paso será crear una aplicación de Heroku y especificar que se trata de una aplicación basada en contenedores. Al crear la aplicación se añadirá automáticamente a nuestro repositorio local un nuevo repositorio remoto con el nombre \textit{heroku}. \\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Creación de la aplicación con Heroku CLI, captionpos=b, frame=single]
$ heroku apps:create <nombre_app>
$ heroku stack:set container
\end{lstlisting}
\end{minipage}

Al igual que en el despliegue de Docker Compose tendremos que definir algunas variables de entorno, en este caso lo realizaremos mediante la CLI de Heroku, en el Código \ref{lst:heroku_env_variables} se muestran las variables mínimas a definir.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Definición de variables de entorno con Heroku CLI, captionpos=b, frame=single, label={lst:heroku_env_variables}]
$ heroku config:set FLASK_APP=vedetra-server.py
$ heroku config:set FLASK_CONFIG=production
$ heroku config:set FLASK_ENV=production
\end{lstlisting}
\end{minipage}

A continuación crearemos el \textit{addon} para PostgreSQL, automáticamente inyectará los datos de conexión al contenedor web mediante la variable de entorno \textit{DATABASE\_URL}.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Creación del addon Heroku PostgreSQL, captionpos=b, frame=single]
$ heroku addons:create heroku-postgresql:hobby-dev
\end{lstlisting}
\end{minipage}

Una vez inicializados todos los componentes solo tendremos que crear un \textit{commit} en el repositorio y subirlo al remoto de Heroku.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Despliegue en Heroku, captionpos=b, frame=single]
$ git add -A
$ git commit -m "Despliegue inicial"
$ git push heroku master
\end{lstlisting}
\end{minipage}

Una vez finalizado el despliegue podemos abrir la aplicación en nuestro navegador predeterminado con el siguiente comando.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Abrir aplicación de Heroku desde la CLI, captionpos=b, frame=single]
$ heroku apps:open
\end{lstlisting}
\end{minipage}

\section{Inicialización }

Una vez arrancado el servidor central y el sensor será necesario crear una entrada para el sensor que realizará el envío de detecciones. Para ello podemos realizar una llamada a la API utilizando el comando \textit{curl}, solo necesitamos la dirección del servidor y el identificador del sensor, las instrucciones para obtener este último dato se encuentran detalladas al final de la Sección \autoref{sect:instalacion_sensor}.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash, caption=Llamada a la API para añadir un nuevo sensor al sistema, captionpos=b, frame=single]
$ curl --location --request POST 'http://<host>:<port>/api/v1.0/sensors/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "id": "363daf8619557863c7b4f9767389cb6c",
    "description": "Sensor 1"
}'
\end{lstlisting}
\end{minipage}

\end{document}
